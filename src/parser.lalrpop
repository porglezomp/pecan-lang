use std::str::FromStr;
use ast::{Ast, Expr, Operator, Type};

grammar;

Comma<X>: Vec<X> = {
    <v:(<X> ",")*> <e:X?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Statement: Ast<'input> = {
    Let,
    Assignment,
    IfElse,
    <Expr> ";" => Ast::Expr(<>),
    For,
};

Assignment: Ast<'input> = {
    <l:Primary> <op:AssignmentOp> <r:Expr> ";" => Ast::Assign { lhs: l, op: op, rhs: r },
};

use ast::Operator::*;
pub AssignmentOp: Operator = {
    "=" => Assign,
    "+=" => AddAssign,
    "-=" => SubAssign,
    "*=" => MulAssign,
    "/=" => DivAssign,
    "%=" => ModAssign,
    "<<=" => LShiftAssign,
    ">>=" => RShiftAssign,
    "&=" => AndAssign,
    "^=" => XorAssign,
    "|=" => OrAssign,
};

pub Type: Type = {
    "I64" => Type::I64,
    // We can't do "()" or else the tokenizer generates a single token for it,
    // and then functions can't have empty arguments.
    "(" ")" => Type::Unit,
    "Bool" => Type::Bool,
};

Let: Ast<'input> = {
    "let" <name:Ident> ":" <ty:Type> "=" <expr:Expr> ";" => Ast::Let { name: name, ty: ty, expr: expr },
};

IfElse: Ast<'input> = {
    "if" "(" <cond:Expr> ")" <then:Block> => Ast::IfElse { cond: cond, then: then, else_: None },
    "if" "(" <cond:Expr> ")" <then:Block> "else" <ifelse:IfElse> =>
        Ast::IfElse { cond: cond, then: then, else_: Some(vec![ifelse]) },
    "if" "(" <cond:Expr> ")" <then:Block> "else" <else_:Block> =>
        Ast::IfElse { cond: cond, then: then, else_: Some(else_) },
};

Block: Vec<Ast<'input>> = {
    "{" <Statement*> "}"
};

For: Ast<'input> = {
    "for" <var:Ident> ":" <ty:Type> "in" <over:Expr> <block:Block> =>
        Ast::For { var: var, ty: ty, over: over, block: block },
};

pub Expr: Expr<'input> = {
    Or
};

Or: Expr<'input> = {
    <l:Or> "or" <r:And> => Expr::make_binop(l, Operator::Or, r),
    And,
};

And: Expr<'input> = {
    <l:And> "and" <r:Equality> => Expr::make_binop(l, Operator::And, r),
    Equality,
};

Equality: Expr<'input> = {
    Equality EqualOp Relation => Expr::make_binop(<>),
    Relation,
};

EqualOp: Operator = {
    "==" => Equal,
    "!=" => NotEqual,
};

Relation: Expr<'input> = {
    Relation RelOp Range => Expr::make_binop(<>),
    Range,
};

RelOp: Operator = {
    "<" => LT,
    ">" => GT,
    "<=" => LTE,
    ">=" => GTE,
};

Range: Expr<'input> = {
    <l:Shift> ".." <r:Shift> => Expr::make_binop(l, Operator::Range, r),
    Shift,
};

Shift: Expr<'input> = {
    Shift ShiftOp Sum => Expr::make_binop(<>),
    Sum,
};

ShiftOp: Operator = {
    "<<" => ShiftLeft,
    ">>" => ShiftRight,
};

Sum: Expr<'input> = {
    Sum SumOp Product => Expr::make_binop(<>),
    Product,
};

SumOp: Operator = {
    "+" => Add,
    "-" => Sub,
};

Product: Expr<'input> = {
    Product ProductOp Unary => Expr::make_binop(<>),
    Unary,
};

ProductOp: Operator = {
    "*" => Mul,
    "/" => Div,
    "%" => Mod,
};

Unary: Expr<'input> = {
    UnaryOp Unary => Expr::make_unop(<>),
    Connection,
};

UnaryOp: Operator = {
    "not" => Not,
    "~" => BitNot,
    "*" => Deref,
    "&" => Address,
};

Connection: Expr<'input> = {
    <obj:Connection> "." <item:Ident> => Expr::GetItem { obj: Box::new(obj), item: item },
    <obj:Connection> "->" <item:Ident> => Expr::GetItem { obj: Box::new(Expr::make_unop(Deref, obj)), item: item },
    <obj:Connection> "[" <idx:Expr> "]" => Expr::Subscript { obj: Box::new(obj), idx: Box::new(idx) },
    Call,
    Primary,
};

pub Call: Expr<'input> = {
    <func:Connection> "(" <args:Comma<Expr>> ")" => Expr::Call { func: Box::new(func), args: args },
};

pub Primary: Expr<'input> = {
    "(" <Expr> ")",
    Ident => Expr::Ident(<>),
    Number => Expr::Int(<>),
};

pub Ident: &'input str = {
    r"[_a-zA-Z][_a-zA-Z0-9]*[!?]?",
};

pub Number: i64 = {
    r"0b[01]+" => i64::from_str_radix(&<>[2..], 2).unwrap(),
    r"0o[0-7]+" => i64::from_str_radix(&<>[2..], 8).unwrap(),
    r"0x[0-9A-Fa-f]+" => i64::from_str_radix(&<>[2..], 16).unwrap(),
    r"[0-9]+" => i64::from_str(<>).unwrap(),
};
