use std::str::FromStr;
use ast::{Ast, Expr, Operator, Type, Case};
use lexer::Token;

grammar<'input>["LALR(1)"];

extern {
    enum Token<'input> {
        "if" => Token::If,
        "else" => Token::Else,
        "for" => Token::For,
        "in" => Token::In,
        "while" => Token::While,
        "switch" => Token::Switch,
        "case" => Token::Case,
        "default" => Token::Default,
        "let" => Token::Let,
        "mut" => Token::Mut,
        "return" => Token::Return,
        "fn" => Token::Fn,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "flag" => Token::Flag,

        "->" => Token::Arrow,

        ";" => Token::Semicolon,
        "," => Token::Comma,
        ":" => Token::Colon,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "[" => Token::OpenSquare,
        "]" => Token::CloseSquare,
        "{" => Token::OpenCurly,
        "}" => Token::CloseCurly,

        "=" => Token::Equals,
        "+=" => Token::PlusEquals,
        "-=" => Token::MinusEquals,
        "*=" => Token::StarEquals,
        "/=" => Token::SlashEquals,
        "%=" => Token::PercentEquals,
        "<<=" => Token::LessThanLessThanEquals,
        ">>=" => Token::GreaterThanGreaterThanEquals,
        "&=" => Token::AndEquals,
        "^=" => Token::CaratEquals,
        "|=" => Token::PipeEquals,

        "or" => Token::Or,
        "and" => Token::And,
        "not" => Token::Not,

        "==" => Token::EqualsEquals,
        "!=" => Token::BangEquals,
        "<" => Token::LessThan,
        ">" => Token::GreaterThan,
        "<=" => Token::LessThanEquals,
        ">=" => Token::GreaterThanEquals,

        "<<" => Token::LessThanLessThan,
        ">>" => Token::GreaterThanGreaterThan,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,

        "." => Token::Dot,
        ".." => Token::DotDot,

        "~" => Token::Tilde,
        "|" => Token::Pipe,
        "^" => Token::Carat,

        "&" => Token::Ampersand,

        "Ident" => Token::Ident(<&'input str>),
        "Int" => Token::Int(<i64>),
        "String" => Token::String(<&'input str>),
        "Char" => Token::Char(<char>),
    }
}

pub File: Vec<Ast<'input>> = Statement*;

Comma<X>: Vec<X> = {
    <v:(<X> ",")*> <e:X?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

NoTrailingComma<X>: Vec<X> = {
    <v:(<X> ",")*> <e:X> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub Type: Type<'input> = {
    "&" <Type> => Type::Pointer(Box::new(<>)),
    "[" <Type> "]" => Type::Array(Box::new(<>)),
    "Ident" => Type::Ident(<>),
    "(" ")" => Type::Unit,
    "(" <NoTrailingComma<Type>> ")" => Type::Tuple(<>),
};

Block = "{" <Statement*> "}";

TypedIdent = <"Ident"> ":" <Type>;

// Statements ///////////////////////////////////////////////////////////////////
pub Statement: Ast<'input> = {
    Let,
    Assignment,
    IfElse,
    For,
    While,
    Switch,
    Return,
    Function,
    Struct,
    Enum,
    Flag,
    <Expr> ";" => Ast::Expr(<>),
};

Let: Ast<'input> =
    "let" <mutable:"mut"?> <name:"Ident"> ":" <ty:Type> "=" <expr:Expr> ";"
        => Ast::Let { name: name, mutable: mutable.is_some(), ty: ty, expr: expr };

Assignment: Ast<'input> = <l:Primary> <op:AssignmentOp> <r:Expr> ";" => Ast::Assign { lhs: l, op: op, rhs: r };

IfElse: Ast<'input> = {
    "if" "(" <cond:Expr> ")" <then:Block> => Ast::IfElse { cond: cond, then: then, else_: None },
    "if" "(" <cond:Expr> ")" <then:Block> "else" <ifelse:IfElse>
        => Ast::IfElse { cond: cond, then: then, else_: Some(vec![ifelse]) },
    "if" "(" <cond:Expr> ")" <then:Block> "else" <else_:Block>
        => Ast::IfElse { cond: cond, then: then, else_: Some(else_) },
};

For: Ast<'input> =
    "for" <var:"Ident"> ":" <ty:Type> "in" "(" <over:Expr> ")" <block:Block>
        => Ast::For { var: var, ty: ty, over: over, block: block };

While: Ast<'input> = "while" "(" <cond:Expr> ")" <block:Block> => Ast::While { cond: cond, block: block };

Switch: Ast<'input> =
    "switch" "(" <cond:Expr> ")" "{" <cases:Case*> "}"
        => Ast::Switch { cond: cond, cases: cases };

Case: Case<'input> = {
    "case" <pat:"Ident"> ":" <body:Statement+> => Case::Case { pattern: pat, body: body },
    "default" ":" <Statement+> => Case::Default(<>),
};

Return: Ast<'input> = "return" <Expr?> ";" => Ast::Return(<>);

Function: Ast<'input> =
    "fn" <name:"Ident"> "(" <args:Comma<TypedIdent>> ")" <ret:("->" <Type>)?> <body:Block>
        => Ast::Function { name: name, args: args, ret: ret.unwrap_or(Type::Unit), body: body };

Struct: Ast<'input> =
    "struct" <name:"Ident"> "{" <members:Comma<TypedIdent>> "}"
        => Ast::Struct { name: name, members: members };

Enum: Ast<'input> =
    "enum" <name:"Ident"> "{" <variants:Comma<"Ident">> "}"
        => Ast::Enum { name: name, variants: variants };

Flag: Ast<'input> =
    "flag" <name:"Ident"> "{" <variants:Comma<"Ident">> "}"
        => Ast::Flag { name: name, variants: variants };

// Expressions //////////////////////////////////////////////////////////////////
pub Expr: Expr<'input> = Range;

Range: Expr<'input> = {
    <l:Or> ".." <r:Or> => Expr::make_binop(l, Operator::Range, r),
    Or,
};

Or: Expr<'input> = {
    <l:Or> "or" <r:And> => Expr::make_binop(l, Operator::Or, r),
    And,
};

And: Expr<'input> = {
    <l:And> "and" <r:Equality> => Expr::make_binop(l, Operator::And, r),
    Equality,
};

Equality: Expr<'input> = {
    Equality EqualOp Relation => Expr::make_binop(<>),
    Relation,
};

Relation: Expr<'input> = {
    Relation RelOp BitOr => Expr::make_binop(<>),
    BitOr,
};

BitOr: Expr<'input> = {
    <l:BitOr> "|" <r:BitXor> => Expr::make_binop(l, Operator::BitOr, r),
    BitXor,
};

BitXor: Expr<'input> = {
    <l:BitXor> "^" <r:BitAnd> => Expr::make_binop(l, Operator::BitXor, r),
    BitAnd,
};

BitAnd: Expr<'input> = {
    <l:BitAnd> "&" <r:Shift> => Expr::make_binop(l, Operator::BitAnd, r),
    Shift,
};

Shift: Expr<'input> = {
    Shift ShiftOp Sum => Expr::make_binop(<>),
    Sum,
};

Sum: Expr<'input> = {
    Sum SumOp Product => Expr::make_binop(<>),
    Product,
};

Product: Expr<'input> = {
    Product ProductOp Unary => Expr::make_binop(<>),
    Unary,
};

Unary: Expr<'input> = {
    UnaryOp Unary => Expr::make_unop(<>),
    Connection,
};

Connection: Expr<'input> = {
    <obj:Connection> "." <item:"Ident"> => Expr::GetItem { obj: Box::new(obj), item: item },
    <obj:Connection> "->" <item:"Ident"> => Expr::GetItem { obj: Box::new(Expr::make_unop(Deref, obj)), item: item },
    <obj:Connection> "[" <idx:Expr> "]" => Expr::Subscript { obj: Box::new(obj), idx: Box::new(idx) },
    <func:Connection> "(" <args:Comma<Expr>> ")" => Expr::Call { func: Box::new(func), args: args },
    Primary,
};

Primary: Expr<'input> = {
    "(" <NoTrailingComma<Expr>> ")" => {
        let mut v = <>;
        if v.len() == 1 {
            v.pop().unwrap()
        } else {
            Expr::Tuple(v)
        }
    },
    "Ident" => Expr::Ident(<>),
    <name:"Ident"> "{" <items:Comma<ItemAssignment>> "}" => Expr::Struct { name: name, items: items },
    "[" <Comma<Expr>> "]" => Expr::List(<>),
    "Int" => Expr::Int(<>),
    "String" => Expr::String(<>),
    "Char" => Expr::Char(<>),
};

ItemAssignment = "." <"Ident"> "=" <Expr>;

// Operators ////////////////////////////////////////////////////////////////////
use ast::Operator::*;
AssignmentOp: Operator = {
    "=" => Assign,
    "+=" => AddAssign,
    "-=" => SubAssign,
    "*=" => MulAssign,
    "/=" => DivAssign,
    "%=" => ModAssign,
    "<<=" => LShiftAssign,
    ">>=" => RShiftAssign,
    "&=" => AndAssign,
    "^=" => XorAssign,
    "|=" => OrAssign,
};

EqualOp: Operator = {
    "==" => Equal,
    "!=" => NotEqual,
};

RelOp: Operator = {
    "<" => LT,
    ">" => GT,
    "<=" => LTE,
    ">=" => GTE,
};

ShiftOp: Operator = {
    "<<" => ShiftLeft,
    ">>" => ShiftRight,
};

SumOp: Operator = {
    "+" => Add,
    "-" => Sub,
};

ProductOp: Operator = {
    "*" => Mul,
    "/" => Div,
    "%" => Mod,
};

UnaryOp: Operator = {
    "not" => Not,
    "~" => BitNot,
    "*" => Deref,
    "&" => Address,
};