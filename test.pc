// Let's test out a comment!
fn main(args: [String]) -> I32 {
  if (args.len < 2) {
    print("You need to pass an argument!");
  } else {  // This comment is in a line!
    print(args[1]);
  }
}

// We need to perform an operator stress test
// Let's test the two-character operators
fn test_it_out() -> Bool {
  let mut x: I64 = 0;
  if ((True == False) != True) {
    /* This is an inline comment */ x += 1;
  }
  x *= 10;
  x /= 2;
  if (x <= 100) {
    x -= 100;
    assert(x <= 0);
  } else {
    return False;
  }
  return True;
}

struct Vec2 { x: F64, y: F64 }
struct Vec3 { x: F64, y: F64, z: F64 }

fn unit?(v: Vec2) -> Bool {
    return (v.x * v.x + v.y + v.y).epsilon_equals(1);
}

let up: Vec2 = Vec2 { .x = 0, .y = 1 };
let right: Vec2 = Vec2 { .x = 1, .y = 0, };

fn fib(n: I64) -> I64 {
    let mut a: I64 = 0;
    let mut b: I64 = 1;
    for _: I64 in (0..n) {
        let c: I64 = b;
        b = a + b;
        a = c;
    }
    return a;
}

let mut _primes: [I64] = [2, 3];
fn next_prime!() {
    // TODO: Implement!
}

fn prime?(n: I64) -> Bool {
    while (n*n >= _primes[_primes.len - 1]) {
        next_prime!();
    }
    for m: I64 in (_primes) {
        if (n*n < m) { return True; }
        if (n%m == 0) { return False; }
    }
    return True;
}

fn dup(n: I64) -> (I64, I64) {
    return (n, n);
}
